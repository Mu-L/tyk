package flags

// Code generated by tyk-flags.
// DO NOT EDIT!

import (
	"context"
	"io"
	"time"

	"github.com/thomaspoignant/go-feature-flag"
	"github.com/thomaspoignant/go-feature-flag/ffuser"
	"github.com/thomaspoignant/go-feature-flag/retriever/fileretriever"
)

// User represents a system user (*SessionData in gateway)
type User interface {
	// GetKey returns the users ID
	GetKey() string

	// IsAnonymous retuns true if user is anon
	IsAnonymous() bool

	// GetCustom returns custom fields for evaluating in flag rules
	GetCustom() map[string]interface{}
}

var _ User = &ffuser.User{}

// FlagKey represents a type-safe feature flag key reference
type FlagKey string

// String implements fmt.Stringer
func (fk FlagKey) String() string {
	return string(fk)
}

// flags wraps GoFeatureFlag and provides it's own API
type flags struct {
	ff *ffclient.GoFeatureFlag
}

// FlagOptions holds overridable values for flags
type FlagOptions struct {
	// FlagsFile (flags/flags.yml)
	FlagsFile string

	// Config file format (yaml)
	FlagsFileFormat string

	// Feature flags client
	FFClient *ffclient.GoFeatureFlag
}

// NewFlagOptions provides default FlagOptions
func NewFlagOptions() FlagOptions {
	return FlagOptions{
		FlagsFile:       "flags/flags.yml",
		FlagsFileFormat: "yaml",
	}
}

// NewFlags creates a default Flags instance
func NewFlags(ctx context.Context) (Flags, error) {
	return NewFlagsWithOptions(ctx, NewFlagOptions())
}

// NewFlagsWithOptions creates a Flags instance with options
func NewFlagsWithOptions(ctx context.Context, options FlagOptions) (Flags, error) {
	var err error
	flags := &flags{}

	// Feature flags client override via options
	if options.FFClient != nil {
		// override with custom feature flags client
		flags.ff = options.FFClient
	} else {
		// create default feature flags client
		flags.ff, err = ffClientDefault(ctx, options)
	}

	return flags, err
}

// BoolVariant defines a bool flag evaluator
type BoolVariant interface {
	// Bool evaluates a key to a boolean value
	Bool(FlagKey, User) bool
}

// StringVariant defines a string flag evaluator
type StringVariant interface {
	// String evaluates a key to a string value
	String(FlagKey, User) string
}

// IntVariant defines a int flag evaluator
type IntVariant interface {
	// Int evaluates a key to an int value
	Int(FlagKey, User) int
}

// Close implements io.Closer
func (f *flags) Close() error {
	if f.ff == nil {
		return nil
	}
	f.ff.Close()
	f.ff = nil
	return nil
}

// Flags is an interface that holds a flag evaluator
type Flags interface {
	io.Closer

	BoolVariant
	StringVariant
	IntVariant
}

// Bool returns a flag as a boolean value
func (f *flags) Bool(key FlagKey, user User) bool {
	if f.ff == nil {
		return false
	}
	has, _ := f.ff.BoolVariation(key.String(), ffUser(user), false)
	return has
}

// String returns a flag as a string value
func (f *flags) String(key FlagKey, user User) string {
	if f.ff == nil {
		return ""
	}
	has, _ := f.ff.StringVariation(key.String(), ffUser(user), "")
	return has
}

// Int returns a flag as an integer value
func (f *flags) Int(key FlagKey, user User) int {
	if f.ff == nil {
		return 0
	}
	has, _ := f.ff.IntVariation(key.String(), ffUser(user), 0)
	return has
}

// ffUser maps our User interface to ffuser.User struct
func ffUser(user User) ffuser.User {
	if user == nil {
		return ffuser.NewAnonymousUser(time.Now().String())
	}

	u := ffuser.NewUserBuilder(user.GetKey())
	u.Anonymous(user.IsAnonymous())

	custom := user.GetCustom()
	for k, v := range custom {
		u.AddCustom(k, v)
	}

	return u.Build()
}

// ffClientDefault implements a default feature flag client
func ffClientDefault(ctx context.Context, options FlagOptions) (*ffclient.GoFeatureFlag, error) {
	return ffclient.New(ffclient.Config{
		PollingInterval: 5,
		Context:         ctx,
		Retriever:       &fileretriever.Retriever{Path: options.FlagsFile},
		FileFormat:      options.FlagsFileFormat,
	})
}
